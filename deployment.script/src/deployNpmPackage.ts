import * as path from "path";
import * as fs from "fs";
import * as getNextNpmPackageVersion from "./getNextNpmPackageVersion";
import * as standardFile from "./standardFile";
import { executeCommand } from "./executeCommand";

/**
 * Deploy a new version of a npm package.
 * @param packageDirectory
 * @param packageName
 * @param packageTag
 * @param npmAuthToken
 * @returns the deployed NPM package version or undefined if deployment was not successful
 */
export function deployNpmPackage(
  packageDirectory: string,
  packageName: string,
  packageTag: string | undefined,
  npmAuthToken: string,
): string | undefined {
  const packageJsonPath = path.join(packageDirectory, "package.json");
  const npmrcPath = path.join(packageDirectory, ".npmrc");

  console.log("Write .npmrc Deployment Token:");
  fs.writeFileSync(npmrcPath, `//registry.npmjs.org/:_authToken=${npmAuthToken}`);

  const maxPublishAttempts: number = 5;
  let currentPublishAttempt: number = 0;
  let npmDeploymentSucceeded = false;

  let deployedNpmPackageVersion = undefined;

  while (!npmDeploymentSucceeded && currentPublishAttempt < maxPublishAttempts) {
    currentPublishAttempt = currentPublishAttempt + 1;
    console.log(
      `Publish to NPM Attempt [${currentPublishAttempt}]/[${maxPublishAttempts}]`,
    );

    const nextNpmPackageVersion = getNextNpmPackageVersion.getNextNpmPackageVersion(
      packageName,
      packageTag,
    );
    console.log(`Update Package Version: [${nextNpmPackageVersion}]`);
    updatePackageVersion(packageJsonPath, nextNpmPackageVersion);

    console.log(`Publish: tag:[${packageTag}]`);
    const publishCommand = generateCommand(
      "npm publish",
      packageTag ? `--tag ${packageTag}` : null,
    );

    try {
      executeCommand(publishCommand, packageDirectory, true);
      npmDeploymentSucceeded = true;
      deployedNpmPackageVersion = nextNpmPackageVersion;
    } catch (e) {
      const wasFailureDueToPreviouslyPublishedDeletedVersion =
        (e as AdditionalInfoError).additionalInfo &&
        isPublishOverPreviouslyPublishVersionErrorString(
          (e as AdditionalInfoError).additionalInfo,
        );

      if (!wasFailureDueToPreviouslyPublishedDeletedVersion) {
        throw e;
      }
    }
  }

  return deployedNpmPackageVersion;
}

///////////////////////////////////////

interface AdditionalInfoError extends Error {
  additionalInfo: string;
}

function isPublishOverPreviouslyPublishVersionErrorString(errorText: string): boolean {
  const phraseMatchIndex = [
    "npm ERR! You cannot publish over the previously published version",
    "npm ERR! Cannot publish over previously published version",
  ]
    .map((phrase) => phrase.toLowerCase())
    .findIndex((phrase) => errorText.toLowerCase().indexOf(phrase) >= 0);
  return phraseMatchIndex >= 0;
}

function updatePackageVersion(packageJsonPath: string, version: string) {
  type Package = { version: string };

  const packageData: Package = standardFile.readFileJson<Package>(packageJsonPath);

  packageData.version = version;

  standardFile.writeFileJson(packageJsonPath, packageData);
}

function generateCommand(...parts: Array<string|null>) {
  return parts.filter((part) => part != null).join(" ");
}
